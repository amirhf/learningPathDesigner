# ADR 001: RAG Architecture with Qdrant, Postgres, and S3

## Status
Accepted

## Context
The Learning Path Designer requires a robust Retrieval-Augmented Generation (RAG) pipeline to curate relevant learning resources for personalized study plans. The system needs to:
1.  Perform semantic search over a growing catalog of learning resources (articles, videos, courses).
2.  Filter resources by metadata (level, duration, media type).
3.  Store full text content or snippets for the LLM context window without bloating the vector database or relational database.
4.  Scale to support multiple tenants and potentially thousands of resources.

## Decision
We have decided to adopt a hybrid data layer architecture:

1.  **Qdrant (Vector Database):**
    *   **Role:** Stores embedding vectors (generated by `e5-base-v2`) and essential metadata for filtering (e.g., skills, level, duration, tenant_id).
    *   **Why:** Qdrant is a high-performance, open-source vector database written in Rust. It supports advanced filtering during the vector search phase (pre-filtering), which is crucial for accuracy. It offers a developer-friendly API and local Docker support.

2.  **PostgreSQL (Relational Database):**
    *   **Role:** Stores the authoritative "source of truth" for resources, skills, user plans, and quiz results. It handles relational integrity, transactions, and structured queries that don't require vector similarity.
    *   **Why:** Postgres is the industry standard for relational data. It ensures data consistency and allows for complex joins when managing user data and plan milestones.

3.  **S3 / Object Storage:**
    *   **Role:** Stores large text blobs (scraped content snippets) used for grounding the LLM during quiz generation.
    *   **Why:** Storing large text fields in Postgres or Qdrant payloads can degrade performance and increase costs. Object storage provides a cheap, scalable solution for unstructured content that is retrieved by ID when needed.

## Consequences

### Positive
*   **Performance:** Vector search is optimized in Qdrant; relational queries are optimized in Postgres.
*   **Scalability:** Each component can scale independently. S3 offloads large data storage.
*   **Flexibility:** We can switch embedding models or rerankers without affecting the primary metadata in Postgres.

### Negative
*   **Complexity:** Requires managing three distinct data stores. Data synchronization (e.g., ensuring a resource exists in all three) must be handled carefully by the ingestion pipeline.
*   **Consistency:** There is a risk of drift between the vector store and the relational DB if updates aren't transactional across systems (eventual consistency is accepted here).

## Alternatives Considered
*   **Postgres with pgvector:** Simpler (single stack), but Qdrant offers more advanced vector-specific features (HNSW, quantization) and separate scaling for the compute-intensive vector search workload.
*   **Elasticsearch:** Good for hybrid search, but can be heavier to operate and configure for pure vector workloads compared to specialized vector DBs like Qdrant.
